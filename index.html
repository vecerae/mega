<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Public Audit â€“ BTC Draw</title>
  <style>
    :root{
      --bg:#0f1220;
      --card:#161a2f;
      --ink:#eaeaf0;
      --muted:rgba(234,234,240,.75);
      --line:#2a2f55;
      --chip:#0c0f1f;
      --accent:#00e0ff;
      --shadow:0 10px 30px rgba(0,0,0,.30);
      --radius:12px;
    }
    *{ box-sizing:border-box; }
    body{
      font-family: Arial, Helvetica, sans-serif;
      background: var(--bg);
      color: var(--ink);
      margin:0;
      padding:0;
    }
    header{
      background: linear-gradient(135deg, #1f2bff, #00c2ff);
      padding: 28px 18px 20px;
      text-align:center;
    }
    header h1{
      margin:0;
      font-size: 26px;
      letter-spacing: .2px;
    }
    header p{
      margin:10px 0 0;
      font-size: 14px;
      opacity: .95;
      word-break: break-all;
      display:flex;
      gap:10px;
      justify-content:center;
      align-items:center;
      flex-wrap:wrap;
    }

    .container{
      max-width:1100px;
      margin: 28px auto;
      padding: 0 18px;
    }
    .top-actions{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      margin-bottom:14px;
      flex-wrap:wrap;
    }
    .pill{
      background: rgba(12,15,31,.60);
      border: 1px solid rgba(234,234,240,.18);
      border-radius: 999px;
      padding: 8px 10px;
      box-shadow: 0 8px 22px rgba(0,0,0,.18);
      backdrop-filter: blur(10px);
      display:flex;
      align-items:center;
      gap:8px;
      color: var(--ink);
    }
    .pill select{
      background: var(--chip);
      color: var(--ink);
      border: 1px solid rgba(234,234,240,.18);
      border-radius: 10px;
      padding: 8px 10px;
      outline:none;
      cursor:pointer;
    }

    .card{
      background: var(--card);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 22px;
      box-shadow: var(--shadow);
    }
    .card h2{
      margin-top:0;
      font-size: 20px;
      border-bottom: 1px solid var(--line);
      padding-bottom: 8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .sub{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.45;
      margin-top: 8px;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 900px){
      .grid{ grid-template-columns: 1fr; }
    }

    ul{ padding-left: 18px; }
    li{ margin-bottom: 6px; word-break: break-word; }
    h3{ margin: 14px 0 8px; font-size: 16px; }
    code{
      background: var(--chip);
      padding: 5px 7px;
      border-radius: 8px;
      display:inline-block;
      margin: 4px 0;
      word-break: break-all;
    }
    .highlight{ color: var(--accent); font-weight:bold; }

    .progress{
      background: var(--chip);
      border-radius: 10px;
      overflow:hidden;
      height: 20px;
      margin-top: 10px;
    }
    .progress-bar{
      background: linear-gradient(90deg, #00c2ff, #1f2bff);
      height:100%;
      width:0%;
      transition: width .35s ease;
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .btn{
      border: 1px solid rgba(234,234,240,.18);
      background: rgba(12,15,31,.65);
      color: var(--ink);
      padding: 9px 12px;
      border-radius: 10px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      box-shadow: 0 8px 18px rgba(0,0,0,.18);
      transition: transform .05s ease, opacity .15s ease;
      font-size: 13px;
    }
    .btn:hover{ opacity:.95; }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      border-color: rgba(0,224,255,.45);
    }
    .btn.small{ padding: 7px 10px; border-radius: 9px; font-size: 12px; }
    .btn.link{
      text-decoration:none;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(12,15,31,.92);
      border: 1px solid rgba(234,234,240,.18);
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 12px 35px rgba(0,0,0,.45);
      font-size: 13px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, bottom .18s ease;
      z-index: 999;
      max-width: calc(100% - 30px);
      text-align:center;
    }
    .toast.show{ opacity: 1; bottom: 24px; }

    .tableWrap{
      background: rgba(12,15,31,.35);
      border: 1px solid rgba(234,234,240,.12);
      border-radius: 12px;
      overflow:hidden;
      margin-top: 10px;
    }
    table{
      width:100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    th, td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(234,234,240,.08);
      vertical-align: top;
    }
    th{
      text-align:left;
      color: rgba(234,234,240,.86);
      font-weight: 700;
      background: rgba(12,15,31,.35);
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .muted{ color: var(--muted); }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(12,15,31,.45);
      border: 1px solid rgba(234,234,240,.14);
      font-size: 12px;
      color: rgba(234,234,240,.9);
    }
    .warn{
      border-color: rgba(255, 205, 0, .25);
      background: rgba(255, 205, 0, .06);
      color: rgba(255, 240, 190, .95);
    }
    .ok{
      border-color: rgba(0, 224, 255, .22);
      background: rgba(0, 224, 255, .07);
      color: rgba(210, 250, 255, .95);
    }

    footer{
      text-align:center;
      padding: 18px;
      font-size: 12px;
      opacity: 0.7;
    }
    a{ color: inherit; }
  </style>
</head>
<body>

<header>
  <h1 data-i18n="title">Public Audit â€“ Transparent Bitcoin Draw</h1>
  <p>
    <span data-i18n="monitoredWalletLabel">Monitored wallet:</span>
    <strong class="mono" id="addrHeader"></strong>
    <button class="btn small primary" id="copyAddrTop" type="button" title="Copy address">
      ğŸ“‹ <span data-i18n="copy">Copy</span>
    </button>
  </p>
</header>

<div class="container">

  <!-- Keep top clean like before; language selector goes here, not in header -->
  <div class="top-actions">
    <div class="pill">
      <span class="muted" data-i18n="langLabel">Language</span>
      <select id="langSelect">
        <option value="en">ğŸ‡ºğŸ‡¸ English</option>
        <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
        <option value="ru">ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
        <option value="pt">ğŸ‡§ğŸ‡· PortuguÃªs</option>
        <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
        <option value="ja">ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª</option>
        <option value="ko">ğŸ‡°ğŸ‡· í•œêµ­ì–´</option>
        <option value="it">ğŸ‡®ğŸ‡¹ Italiano</option>
        <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
      </select>
    </div>
  </div>

  <div class="grid">

    <div class="card" id="participants">
      <h2>
        <span data-i18n="currentRoundTitle">Current Round</span>
        <span class="badge ok" id="statusBadge">â— Live</span>
      </h2>

      <div class="row" style="justify-content:space-between">
        <div>
          <div class="sub">
            <span data-i18n="exactEntriesLabel">Exact-value entries received:</span>
            <span class="highlight" id="entryCount">0</span> / <span id="cycleTarget">200</span>
          </div>
          <div class="progress"><div class="progress-bar" id="progressBar"></div></div>
          <div class="sub" style="margin-top:8px">
            <span data-i18n="missingLabel">Missing</span>
            <span class="highlight" id="missing">200</span>
            <span data-i18n="missingSuffix">entries to close the cycle.</span>
          </div>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(234,234,240,.08);margin:14px 0">

      <div class="sub"><strong data-i18n="participateTitle">How to participate</strong></div>
      <ul>
        <li>
          <span data-i18n="sendExact">Send exactly</span>
          <code class="mono" id="exactBtc"></code>
          <button class="btn small" id="copyAmount" type="button">ğŸ“‹ <span data-i18n="copy">Copy</span></button>
        </li>
        <li>
          <span data-i18n="toAddress">To this address:</span><br>
          <code class="mono" id="addrCode"></code>
          <button class="btn small primary" id="copyAddr" type="button">ğŸ“‹ <span data-i18n="copyAddress">Copy address</span></button>
        </li>
        <li data-i18n="confirmations">Wait at least 2 confirmations.</li>
      </ul>

      <div class="row" style="margin-top:10px">
        <a class="btn link" id="openMempoolAddress" target="_blank" rel="noopener">
          ğŸ” <span data-i18n="openExplorer">Open in explorer</span>
        </a>
        <button class="btn" id="refreshBtn" type="button">
          ğŸ”„ <span data-i18n="refresh">Refresh</span>
        </button>
      </div>

      <div class="sub" style="margin-top:10px" data-i18n="auditTip">
        Tip: anyone can verify entries and payouts directly on the Bitcoin blockchain using a public explorer.
      </div>
    </div>

    <div class="card" id="winners">
      <h2>
        <span data-i18n="lastWinnersTitle">Latest Winners (last 5 payouts)</span>
        <button class="btn small" id="exportPayouts" type="button">â¬‡ï¸ <span data-i18n="exportJson">Export JSON</span></button>
      </h2>
      <ul id="winnerList">
        <li data-i18n="loadingExplorer">Loading explorer data...</li>
      </ul>

      <div class="sub">
        <strong data-i18n="prizeTitle">Prize</strong>:
        <span class="highlight" id="prizeBtc"></span>
        <span class="muted">(</span><span class="highlight" id="prizeEntries"></span><span class="muted" data-i18n="entriesWord"> entries</span><span class="muted">)</span>
      </div>

      <hr style="border:none;border-top:1px solid rgba(234,234,240,.08);margin:14px 0">

      <h3 data-i18n="whyBetterTitle">ğŸ† Why this is better than traditional lotteries</h3>
      <ul>
        <li data-i18n="betterLi1">Much higher odds: the participant count is capped (no millions of tickets).</li>
        <li data-i18n="betterLi2">Honesty by design: entries and payouts are public on-chain and verifiable.</li>
        <li data-i18n="betterLi3">Fast settlement: payout can be made right after the cycle closes (after confirmations).</li>
        <li data-i18n="betterLi4">No hidden tiers: every entry is identical for everyone.</li>
        <li data-i18n="betterLi5">Clear rules: wrong amounts do not count â€” no ambiguity.</li>
        <li data-i18n="betterLi6">No automatic â€œslicesâ€ like many lotteries (operator rules are explicit). Local taxes may still apply depending on your country.</li>
      </ul>

      <div class="sub" data-i18n="disclaimer">
        Disclaimer: Bitcoin transactions may include miner fees and are subject to network conditions. BTC price volatility can affect local-currency value. Ensure legality in your jurisdiction and consult about tax obligations.
      </div>
    </div>

  </div>

  <!-- AUDIT TOOLBOX -->
  <div class="card" id="audit">
    <h2>
      <span data-i18n="auditTitle">Audit Toolbox (verify fairness yourself)</span>
      <div class="row">
        <button class="btn small" id="exportCycle" type="button">â¬‡ï¸ <span data-i18n="exportCycle">Export current cycle</span></button>
        <button class="btn small primary" id="recalcBtn" type="button">âœ… <span data-i18n="recalc">Recalculate winner</span></button>
      </div>
    </h2>

    <div class="sub" data-i18n="auditIntro">
      This section makes auditing easy: it shows the exact entry list (ordered), the seed blockhash, and a deterministic winner calculation.
      Anyone can reproduce the same result.
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="card" style="margin:0;background:rgba(12,15,31,.35);border:1px solid rgba(234,234,240,.10)">
        <h3 style="margin-top:0" data-i18n="auditStepsTitle">How to validate (quick steps)</h3>
        <ol class="sub" style="margin:0;padding-left:18px">
          <li data-i18n="step1">Open the monitored address in a public explorer and confirm the exact entries exist on-chain.</li>
          <li data-i18n="step2">Verify the entry list ordering (block height â†’ txid â†’ output index) matches what you see in the table below.</li>
          <li data-i18n="step3">Take the seed blockhash (block of the last entry of the cycle).</li>
          <li data-i18n="step4">Concatenate all cycle txids + seed blockhash, then SHA-256.</li>
          <li data-i18n="step5">Winner index = hash as a big integer mod TARGET_ENTRIES.</li>
        </ol>
      </div>

      <div class="card" style="margin:0;background:rgba(12,15,31,.35);border:1px solid rgba(234,234,240,.10)">
        <h3 style="margin-top:0" data-i18n="auditDataTitle">Audit data (auto-filled)</h3>

        <div class="sub">
          <strong data-i18n="cycleId">Cycle ID</strong>: <span class="mono" id="cycleId">â€”</span>
          <button class="btn small" id="copyCycleId" type="button">ğŸ“‹ <span data-i18n="copy">Copy</span></button>
        </div>

        <div class="sub">
          <strong data-i18n="seedBlockhash">Seed blockhash</strong>:<br>
          <code class="mono" id="seedBlockhash">â€”</code>
          <button class="btn small" id="copySeed" type="button">ğŸ“‹ <span data-i18n="copy">Copy</span></button>
        </div>

        <div class="sub">
          <strong data-i18n="winnerIndex">Winner index</strong>: <span class="highlight mono" id="winnerIndex">â€”</span>
          &nbsp; <strong data-i18n="winnerEntry">Winner entry txid</strong>:<br>
          <code class="mono" id="winnerTxid">â€”</code>
          <button class="btn small" id="copyWinnerTxid" type="button">ğŸ“‹ <span data-i18n="copy">Copy</span></button>
        </div>

        <div class="row" style="margin-top:10px">
          <a class="btn link" id="openWinnerTx" target="_blank" rel="noopener">ğŸ” <span data-i18n="openWinnerTx">Open winner tx</span></a>
          <button class="btn" id="copyVerifyString" type="button">ğŸ§¾ <span data-i18n="copyVerify">Copy verify string</span></button>
        </div>

        <div class="sub" style="margin-top:10px" data-i18n="verifyStringInfo">
          â€œVerify stringâ€ = txid1|txid2|...|txidN|seed_blockhash (you can hash it with SHA-256 anywhere).
        </div>
      </div>
    </div>

    <h3 style="margin-top:16px" data-i18n="entryListTitle">Ordered entry list (current cycle)</h3>
    <div class="sub" data-i18n="entryListHint">
      Only exact payments to the monitored address count. Wrong amounts are ignored.
    </div>

    <div class="tableWrap">
      <table>
        <thead>
          <tr>
            <th style="width:68px">#</th>
            <th data-i18n="thTxid">Txid</th>
            <th style="width:120px" data-i18n="thBlock">Block</th>
            <th data-i18n="thFrom">From (best-effort)</th>
            <th style="width:120px" data-i18n="thAmount">Amount</th>
            <th style="width:120px" data-i18n="thActions">Actions</th>
          </tr>
        </thead>
        <tbody id="entryTbody">
          <tr>
            <td colspan="6" class="muted" data-i18n="loadingEntries">Loading entries...</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="sub" style="margin-top:10px">
      <span class="badge warn" id="auditNoteBadge">â„¹ï¸</span>
      <span data-i18n="auditNote">
        Note: â€œFromâ€ address is inferred from the first input (vin[0]) as provided by the explorer API and may not always represent the participantâ€™s receiving address.
      </span>
    </div>
  </div>

</div>

<footer>
  <span data-i18n="footerText">Decentralized audit â€¢ Total transparency â€¢ Bitcoin</span>
</footer>

<div class="toast" id="toast">Copied!</div>

<script>
/** =========================
 *  CONFIG (edit as you like)
 *  ========================= */
const ADDRESS = 'bc1qmxcgv8wtj7zdx8t9xtr6xcfx5yuqeddqwx5wca';
const EXACT_VALUE = 14000; // satoshis (0.00014000 BTC)
const TARGET_ENTRIES = 200;

// Economics (edit freely)
const PRIZE_ENTRIES = 195;
const PRIZE_SATS = PRIZE_ENTRIES * EXACT_VALUE;

// Explorer base (mempool.space)
const EXPLORER = 'https://mempool.space';
const API = EXPLORER + '/api';

/** =========================
 *  i18n â€“ lightweight (keeps your original vibe)
 *  Default: English
 *  ========================= */
const i18n = {
  en: {
    title: "Public Audit â€“ Transparent Bitcoin Draw",
    monitoredWalletLabel: "Monitored wallet:",
    langLabel: "Language",
    copy: "Copy",
    copyAddress: "Copy address",
    currentRoundTitle: "Current Round",
    exactEntriesLabel: "Exact-value entries received:",
    missingLabel: "Missing",
    missingSuffix: "entries to close the cycle.",
    participateTitle: "How to participate",
    sendExact: "Send exactly",
    toAddress: "To this address:",
    confirmations: "Wait at least 2 confirmations.",
    openExplorer: "Open in explorer",
    refresh: "Refresh",
    auditTip: "Tip: anyone can verify entries and payouts directly on the Bitcoin blockchain using a public explorer.",
    lastWinnersTitle: "Latest Winners (last 5 payouts)",
    loadingExplorer: "Loading explorer data...",
    exportJson: "Export JSON",
    prizeTitle: "Prize",
    entriesWord: " entries",
    whyBetterTitle: "ğŸ† Why this is better than traditional lotteries",
    betterLi1: "Much higher odds: the participant count is capped (no millions of tickets).",
    betterLi2: "Honesty by design: entries and payouts are public on-chain and verifiable.",
    betterLi3: "Fast settlement: payout can be made right after the cycle closes (after confirmations).",
    betterLi4: "No hidden tiers: every entry is identical for everyone.",
    betterLi5: "Clear rules: wrong amounts do not count â€” no ambiguity.",
    betterLi6: "No automatic â€œslicesâ€ like many lotteries (operator rules are explicit). Local taxes may still apply depending on your country.",
    disclaimer: "Disclaimer: Bitcoin transactions may include miner fees and are subject to network conditions. BTC price volatility can affect local-currency value. Ensure legality in your jurisdiction and consult about tax obligations.",
    auditTitle: "Audit Toolbox (verify fairness yourself)",
    auditIntro: "This section makes auditing easy: it shows the exact entry list (ordered), the seed blockhash, and a deterministic winner calculation. Anyone can reproduce the same result.",
    exportCycle: "Export current cycle",
    recalc: "Recalculate winner",
    auditStepsTitle: "How to validate (quick steps)",
    step1: "Open the monitored address in a public explorer and confirm the exact entries exist on-chain.",
    step2: "Verify the entry list ordering (block height â†’ txid â†’ output index) matches what you see in the table below.",
    step3: "Take the seed blockhash (block of the last entry of the cycle).",
    step4: "Concatenate all cycle txids + seed blockhash, then SHA-256.",
    step5: "Winner index = hash as a big integer mod TARGET_ENTRIES.",
    auditDataTitle: "Audit data (auto-filled)",
    cycleId: "Cycle ID",
    seedBlockhash: "Seed blockhash",
    winnerIndex: "Winner index",
    winnerEntry: "Winner entry txid",
    openWinnerTx: "Open winner tx",
    copyVerify: "Copy verify string",
    verifyStringInfo: "â€œVerify stringâ€ = txid1|txid2|...|txidN|seed_blockhash (you can hash it with SHA-256 anywhere).",
    entryListTitle: "Ordered entry list (current cycle)",
    entryListHint: "Only exact payments to the monitored address count. Wrong amounts are ignored.",
    thTxid: "Txid",
    thBlock: "Block",
    thFrom: "From (best-effort)",
    thAmount: "Amount",
    thActions: "Actions",
    loadingEntries: "Loading entries...",
    auditNote: "Note: â€œFromâ€ address is inferred from the first input (vin[0]) as provided by the explorer API and may not always represent the participantâ€™s receiving address.",
    footerText: "Decentralized audit â€¢ Total transparency â€¢ Bitcoin"
  },

  pt: {
    title: "Auditoria PÃºblica â€“ Sorteio Transparente em Bitcoin",
    monitoredWalletLabel: "Carteira monitorada:",
    langLabel: "Idioma",
    copy: "Copiar",
    copyAddress: "Copiar carteira",
    currentRoundTitle: "Rodada Atual",
    exactEntriesLabel: "Entradas com valor exato:",
    missingLabel: "Faltam",
    missingSuffix: "entradas para fechar o ciclo.",
    participateTitle: "Como participar",
    sendExact: "Envie exatamente",
    toAddress: "Para este endereÃ§o:",
    confirmations: "Aguarde no mÃ­nimo 2 confirmaÃ§Ãµes.",
    openExplorer: "Abrir no explorador",
    refresh: "Atualizar",
    auditTip: "Dica: qualquer pessoa pode verificar entradas e payouts diretamente na blockchain usando um explorador pÃºblico.",
    lastWinnersTitle: "Ãšltimos Ganhadores (Ãºltimos 5 payouts)",
    loadingExplorer: "Carregando dados do explorador...",
    exportJson: "Exportar JSON",
    prizeTitle: "PrÃªmio",
    entriesWord: " entradas",
    whyBetterTitle: "ğŸ† Por que isso Ã© melhor do que loterias tradicionais",
    betterLi1: "Chance muito maior: nÃºmero de participantes limitado (nÃ£o sÃ£o milhÃµes de bilhetes).",
    betterLi2: "Honestidade por design: entradas e payouts sÃ£o pÃºblicos na blockchain e verificÃ¡veis.",
    betterLi3: "Pagamento rÃ¡pido: o payout pode ser feito assim que o ciclo fecha (apÃ³s confirmaÃ§Ãµes).",
    betterLi4: "Sem nÃ­veis ocultos: cada entrada Ã© igual para todos.",
    betterLi5: "Regras claras: valores errados nÃ£o contam â€” sem ambiguidade.",
    betterLi6: "Sem â€œfatias automÃ¡ticasâ€ como em muitas loterias (regras explÃ­citas). Impostos locais ainda podem se aplicar conforme seu paÃ­s.",
    disclaimer: "Aviso: transaÃ§Ãµes de Bitcoin podem incluir taxas e dependem da rede. A volatilidade do BTC pode afetar o valor em moeda local. Verifique legalidade e obrigaÃ§Ãµes fiscais.",
    auditTitle: "Caixa de Ferramentas de Auditoria (verifique a justiÃ§a)",
    auditIntro: "Esta seÃ§Ã£o facilita a auditoria: mostra a lista exata de entradas (ordenada), o seed blockhash e um cÃ¡lculo determinÃ­stico do vencedor. Qualquer pessoa pode reproduzir o mesmo resultado.",
    exportCycle: "Exportar ciclo atual",
    recalc: "Recalcular vencedor",
    auditStepsTitle: "Como validar (passo a passo rÃ¡pido)",
    step1: "Abra o endereÃ§o monitorado em um explorador e confirme as entradas exatas on-chain.",
    step2: "Verifique se a ordenaÃ§Ã£o (bloco â†’ txid â†’ Ã­ndice de saÃ­da) bate com a tabela abaixo.",
    step3: "Pegue o seed blockhash (bloco da Ãºltima entrada do ciclo).",
    step4: "Concatene todos os txids do ciclo + seed blockhash e aplique SHA-256.",
    step5: "Ãndice vencedor = hash como inteiro grande mod TARGET_ENTRIES.",
    auditDataTitle: "Dados de auditoria (preenchido automaticamente)",
    cycleId: "ID do ciclo",
    seedBlockhash: "Seed blockhash",
    winnerIndex: "Ãndice do vencedor",
    winnerEntry: "Txid da entrada vencedora",
    openWinnerTx: "Abrir tx vencedora",
    copyVerify: "Copiar string de verificaÃ§Ã£o",
    verifyStringInfo: "â€œString de verificaÃ§Ã£oâ€ = txid1|txid2|...|txidN|seed_blockhash (vocÃª pode hashear com SHA-256 em qualquer lugar).",
    entryListTitle: "Lista ordenada de entradas (ciclo atual)",
    entryListHint: "Somente pagamentos exatos para a carteira monitorada contam. Valores errados sÃ£o ignorados.",
    thTxid: "Txid",
    thBlock: "Bloco",
    thFrom: "Origem (melhor esforÃ§o)",
    thAmount: "Valor",
    thActions: "AÃ§Ãµes",
    loadingEntries: "Carregando entradas...",
    auditNote: "Nota: o campo â€œOrigemâ€ Ã© inferido do primeiro input (vin[0]) conforme a API do explorador, e pode nÃ£o representar o endereÃ§o de recebimento do participante.",
    footerText: "Auditoria descentralizada â€¢ TransparÃªncia total â€¢ Bitcoin"
  },

  es: { ...null }, ru: { ...null }, zh: { ...null }, ja: { ...null }, ko: { ...null }, it: { ...null }, fr: { ...null }
};
// Minimal fallback for other languages: keep English
function getDict(lang){
  return i18n[lang] && i18n[lang].title ? i18n[lang] : i18n.en;
}
function applyI18n(lang){
  const dict = getDict(lang);
  document.documentElement.lang = lang;
  document.querySelectorAll("[data-i18n]").forEach(el=>{
    const key = el.getAttribute("data-i18n");
    if(dict[key]) el.textContent = dict[key];
  });
}

/** =========================
 *  UI helpers
 *  ========================= */
function toast(msg){
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"), 1200);
}
async function copyText(text){
  try{
    await navigator.clipboard.writeText(text);
    toast("Copied!");
  }catch(e){
    // fallback
    const ta = document.createElement("textarea");
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
    toast("Copied!");
  }
}
function satsToBtcString(sats){
  return (sats/100000000).toFixed(8) + " BTC";
}
function short(s, n=12){
  if(!s) return "â€”";
  return s.length<=n? s : (s.slice(0, n) + "â€¦");
}
function downloadJson(filename, obj){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

/** =========================
 *  Data model
 *  ========================= */
let payoutsCache = [];
let currentCycleEntries = []; // ordered
let currentCycleId = 0;
let currentSeedBlockhash = "";
let currentVerifyString = "";
let currentWinnerIndex = null;
let currentWinnerTxid = "";

/** =========================
 *  Fetch helpers (pagination)
 *  mempool API returns 25 txs per page for /address/:address/txs
 *  Use /address/:address/txs/chain/:last_txid to paginate
 *  ========================= */
async function fetchAddressTxsAll(maxPages=30){
  let all = [];
  let url = `${API}/address/${ADDRESS}/txs`;
  for(let i=0;i<maxPages;i++){
    const res = await fetch(url);
    if(!res.ok) break;
    const page = await res.json();
    if(!Array.isArray(page) || page.length===0) break;
    all.push(...page);
    const last = page[page.length-1];
    if(!last || !last.txid) break;
    url = `${API}/address/${ADDRESS}/txs/chain/${last.txid}`;
    if(page.length < 25) break;
  }
  return all;
}

/** =========================
 *  Extract entries + payouts from tx list
 *  ========================= */
function extractFromTxs(txs){
  // Entries: exact output to ADDRESS with EXACT_VALUE
  const entries = [];
  const payouts = [];

  txs.forEach(tx=>{
    // payouts: any output to NOT ADDRESS with value > EXACT_VALUE (best-effort heuristic)
    if(Array.isArray(tx.vout)){
      tx.vout.forEach((v, voutIndex)=>{
        if(v?.scriptpubkey_address && v.scriptpubkey_address !== ADDRESS && v.value > EXACT_VALUE){
          payouts.push({
            txid: tx.txid,
            to: v.scriptpubkey_address,
            sats: v.value,
            vout: voutIndex,
            height: tx.status?.block_height ?? null,
            block_hash: tx.status?.block_hash ?? null,
            time: tx.status?.block_time ?? null
          });
        }
      });
    }

    // entries: exact payment to ADDRESS
    if(Array.isArray(tx.vout)){
      tx.vout.forEach((v, voutIndex)=>{
        if(v?.scriptpubkey_address === ADDRESS && v.value === EXACT_VALUE){
          // best-effort "from": first input prevout address
          const fromAddr = tx.vin?.[0]?.prevout?.scriptpubkey_address || tx.vin?.[0]?.prevout?.scriptpubkey_address || null;

          entries.push({
            txid: tx.txid,
            vout: voutIndex,
            sats: v.value,
            height: tx.status?.block_height ?? null,
            block_hash: tx.status?.block_hash ?? null,
            time: tx.status?.block_time ?? null,
            from: fromAddr
          });
        }
      });
    }
  });

  // Sort entries in deterministic order: block_height asc, txid asc, vout asc
  entries.sort((a,b)=>{
    const ah = a.height ?? 0, bh = b.height ?? 0;
    if(ah !== bh) return ah - bh;
    if(a.txid !== b.txid) return a.txid < b.txid ? -1 : 1;
    return (a.vout ?? 0) - (b.vout ?? 0);
  });

  // Sort payouts newest-first by height/time
  payouts.sort((a,b)=>{
    const ah = a.height ?? 0, bh = b.height ?? 0;
    if(ah !== bh) return bh - ah;
    const at = a.time ?? 0, bt = b.time ?? 0;
    return bt - at;
  });

  return {entries, payouts};
}

/** =========================
 *  Determine current cycle entries
 *  ========================= */
function computeCurrentCycle(allEntries){
  const total = allEntries.length;
  currentCycleId = Math.floor(total / TARGET_ENTRIES) + 1; // human-friendly cycle numbering
  const remainder = total % TARGET_ENTRIES;
  const start = total - remainder;
  currentCycleEntries = allEntries.slice(start); // last remainder entries (current cycle)
  return { total, remainder };
}

/** =========================
 *  SHA-256 + BigInt mod
 *  ========================= */
async function sha256Hex(str){
  const enc = new TextEncoder().encode(str);
  const digest = await crypto.subtle.digest("SHA-256", enc);
  const arr = Array.from(new Uint8Array(digest));
  return arr.map(b=>b.toString(16).padStart(2,"0")).join("");
}
function hexToBigInt(hex){
  return BigInt("0x" + hex);
}

/** Winner calc (deterministic) */
async function recalcWinner(){
  if(currentCycleEntries.length === 0){
    currentSeedBlockhash = "";
    currentWinnerIndex = null;
    currentWinnerTxid = "";
    currentVerifyString = "";
    paintAuditFields();
    toast("No entries yet.");
    return;
  }

  // Seed = block hash of the LAST entry we currently have (best-effort).
  // If the cycle is complete, this is the last entry of the cycle.
  const last = currentCycleEntries[currentCycleEntries.length - 1];
  currentSeedBlockhash = last.block_hash || "";

  // Build verify string: txid1|txid2|...|txidN|seed_blockhash
  const txids = currentCycleEntries.map(e=>e.txid);
  currentVerifyString = txids.join("|") + "|" + (currentSeedBlockhash || "");

  // If seed blockhash missing (unconfirmed), can't finalize deterministically
  if(!currentSeedBlockhash){
    currentWinnerIndex = null;
    currentWinnerTxid = "";
    paintAuditFields();
    toast("Seed blockhash unavailable (unconfirmed).");
    return;
  }

  const h = await sha256Hex(currentVerifyString);
  const idx = Number(hexToBigInt(h) % BigInt(TARGET_ENTRIES)); // deterministic
  currentWinnerIndex = idx;

  // Winner txid: for a full cycle, index maps to cycle entries.
  // For an incomplete cycle, it still maps deterministically, but â€œwinnerâ€ is only final when cycle closes.
  const winnerEntry = currentCycleEntries[idx] || null;
  currentWinnerTxid = winnerEntry?.txid || "";

  paintAuditFields();
}

/** =========================
 *  Render
 *  ========================= */
function paintWinners(){
  const ul = document.getElementById("winnerList");
  ul.innerHTML = "";

  const top5 = payoutsCache.slice(0,5);
  if(top5.length === 0){
    const li = document.createElement("li");
    li.textContent = "â€”";
    ul.appendChild(li);
    return;
  }

  top5.forEach(p=>{
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.href = `${EXPLORER}/tx/${p.txid}`;
    a.target = "_blank";
    a.rel = "noopener";
    a.textContent = `${p.to}  â€¢  ${satsToBtcString(p.sats)}`;
    li.appendChild(a);
    ul.appendChild(li);
  });
}

function paintProgress(remainder){
  document.getElementById("entryCount").textContent = remainder;
  document.getElementById("cycleTarget").textContent = TARGET_ENTRIES;
  document.getElementById("missing").textContent = TARGET_ENTRIES - remainder;
  document.getElementById("progressBar").style.width = (remainder / TARGET_ENTRIES * 100) + "%";

  const badge = document.getElementById("statusBadge");
  if(remainder === 0){
    badge.className = "badge ok";
    badge.textContent = "â— Live";
  } else {
    badge.className = "badge ok";
    badge.textContent = "â— Live";
  }
}

function paintEntryTable(){
  const tbody = document.getElementById("entryTbody");
  tbody.innerHTML = "";

  if(currentCycleEntries.length === 0){
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 6;
    td.className = "muted";
    td.textContent = "â€”";
    tr.appendChild(td);
    tbody.appendChild(tr);
    return;
  }

  currentCycleEntries.forEach((e, i)=>{
    const tr = document.createElement("tr");

    const tdI = document.createElement("td");
    tdI.textContent = i;
    tdI.className = "mono";
    tr.appendChild(tdI);

    const tdTx = document.createElement("td");
    tdTx.className = "mono";
    tdTx.innerHTML = `<a href="${EXPLORER}/tx/${e.txid}" target="_blank" rel="noopener">${e.txid}</a><div class="muted">vout: ${e.vout}</div>`;
    tr.appendChild(tdTx);

    const tdB = document.createElement("td");
    tdB.className = "mono";
    tdB.innerHTML = `${e.height ?? "â€”"}<div class="muted">${e.block_hash ? short(e.block_hash, 14) : "â€”"}</div>`;
    tr.appendChild(tdB);

    const tdFrom = document.createElement("td");
    tdFrom.className = "mono";
    tdFrom.textContent = e.from || "â€”";
    tr.appendChild(tdFrom);

    const tdAmt = document.createElement("td");
    tdAmt.className = "mono";
    tdAmt.textContent = satsToBtcString(e.sats);
    tr.appendChild(tdAmt);

    const tdAct = document.createElement("td");
    tdAct.innerHTML = `
      <button class="btn small" type="button" data-copy-tx="${e.txid}">ğŸ“‹ Txid</button>
      <button class="btn small" type="button" data-copy-from="${e.from || ""}">ğŸ“‹ From</button>
    `;
    tr.appendChild(tdAct);

    tbody.appendChild(tr);
  });

  // bind copy buttons inside table
  tbody.querySelectorAll("[data-copy-tx]").forEach(btn=>{
    btn.addEventListener("click", ()=>copyText(btn.getAttribute("data-copy-tx")));
  });
  tbody.querySelectorAll("[data-copy-from]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const v = btn.getAttribute("data-copy-from");
      if(!v) return toast("No address.");
      copyText(v);
    });
  });
}

function paintAuditFields(){
  document.getElementById("cycleId").textContent = String(currentCycleId);
  document.getElementById("seedBlockhash").textContent = currentSeedBlockhash || "â€”";
  document.getElementById("winnerIndex").textContent = (currentWinnerIndex === null ? "â€”" : String(currentWinnerIndex));
  document.getElementById("winnerTxid").textContent = currentWinnerTxid || "â€”";

  const openWinner = document.getElementById("openWinnerTx");
  if(currentWinnerTxid){
    openWinner.href = `${EXPLORER}/tx/${currentWinnerTxid}`;
  } else {
    openWinner.href = `${EXPLORER}`;
  }
}

/** =========================
 *  Main load
 *  ========================= */
async function loadData(){
  // UI static
  document.getElementById("addrHeader").textContent = ADDRESS;
  document.getElementById("addrCode").textContent = ADDRESS;
  document.getElementById("exactBtc").textContent = satsToBtcString(EXACT_VALUE);
  document.getElementById("prizeEntries").textContent = PRIZE_ENTRIES;
  document.getElementById("prizeBtc").textContent = satsToBtcString(PRIZE_SATS);

  const openAddr = document.getElementById("openMempoolAddress");
  openAddr.href = `${EXPLORER}/address/${ADDRESS}`;

  // fetch
  const txs = await fetchAddressTxsAll();
  const {entries, payouts} = extractFromTxs(txs);
  payoutsCache = payouts;

  const {remainder} = computeCurrentCycle(entries);

  paintProgress(remainder);
  paintWinners();
  paintEntryTable();

  // Seed and winner calc are meaningful only when last entry is confirmed (has block hash)
  await recalcWinner();
}

/** =========================
 *  Events
 *  ========================= */
document.getElementById("copyAddrTop").addEventListener("click", ()=>copyText(ADDRESS));
document.getElementById("copyAddr").addEventListener("click", ()=>copyText(ADDRESS));
document.getElementById("copyAmount").addEventListener("click", ()=>copyText(satsToBtcString(EXACT_VALUE)));
document.getElementById("refreshBtn").addEventListener("click", loadData);

document.getElementById("exportPayouts").addEventListener("click", ()=>{
  downloadJson("payouts_last_seen.json", payoutsCache.slice(0,50));
});

document.getElementById("exportCycle").addEventListener("click", ()=>{
  downloadJson(`cycle_${currentCycleId}_entries.json`, {
    cycleId: currentCycleId,
    address: ADDRESS,
    exact_sats: EXACT_VALUE,
    target_entries: TARGET_ENTRIES,
    seed_blockhash: currentSeedBlockhash || null,
    verify_string: currentVerifyString || null,
    winner_index: currentWinnerIndex,
    winner_txid: currentWinnerTxid || null,
    entries: currentCycleEntries
  });
});

document.getElementById("recalcBtn").addEventListener("click", recalcWinner);

document.getElementById("copyCycleId").addEventListener("click", ()=>copyText(String(currentCycleId)));
document.getElementById("copySeed").addEventListener("click", ()=>{
  if(!currentSeedBlockhash) return toast("No seed.");
  copyText(currentSeedBlockhash);
});
document.getElementById("copyWinnerTxid").addEventListener("click", ()=>{
  if(!currentWinnerTxid) return toast("No txid.");
  copyText(currentWinnerTxid);
});
document.getElementById("copyVerifyString").addEventListener("click", ()=>{
  if(!currentVerifyString) return toast("No verify string.");
  copyText(currentVerifyString);
});

// Language
const langSelect = document.getElementById("langSelect");
langSelect.value = "en";
applyI18n("en");
langSelect.addEventListener("change", (e)=>applyI18n(e.target.value));

/** =========================
 *  Init
 *  ========================= */
loadData();
</script>

</body>
</html>
